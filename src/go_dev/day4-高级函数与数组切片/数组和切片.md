<!-- TOC -->

- [数组相关特性](#数组相关特性)
  - [斐波那契数列(非递归函数)](#斐波那契数列非递归函数)
  - [数组的初始化](#数组的初始化)
  - [多维数组](#多维数组)
  - [多维数组遍历](#多维数组遍历)
- [切片相关特性](#切片相关特性)
  - [切片的初始化](#切片的初始化)

<!-- /TOC -->
# 数组相关特性
1. 数组是同一种数据类型的固定长度的序列

2. 数组的定义: 
`var a [len]int,比如：var a[6]int`，一旦定义，长度不能变
3. 长度是数组类型的一部分
```
长度是数组类型的一部分，因此，var a[5] int和 var a[10] int是不同的类型
```
4. 数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1
5. 访问越界，如果下标在数组合法范围之外，则触发访问越界，会panic
6. 数组是值类型，因此改变副本的值，不会改变本身的值
```go
package main

import (
	"fmt"
)

// 访问越界问题
func test1() {
	var a [10]int
	// j := 10 // 不能超出数组的范围，会报错panic
	j := 9
	a[0] = 10
	a[j] = 100
	fmt.Println(a)

	for i := 0; i < len(a); i++ {
		fmt.Println(a[i])
	}
	for index, val := range a {
		fmt.Printf("a[%d]=%d\n", index, val)
	}
}

//数组是值类型，改变副本的值，不会改变本身的值
func test2() {
	var a [10]int
	b := a
	b[0] = 101
	fmt.Println(a) //[0 0 0 0 0 0 0 0 0 0] a的值没有发生变化
}
func test3(arr [5]int) {
	arr[0] = 1000
}

// 如果需要改变原来的数组的值需要传入地址进去
func test4(arr *[5]int) {
	arr[0] = 1000
}

func main() {
	test1()
	test2()

	var a [5]int
	test3(a)
	fmt.Println(a) //[0 0 0 0 0]
	test4(&a)      //&a传入值类型的地址
	fmt.Println(a) //[1000 0 0 0 0]
}
```
## 斐波那契数列(非递归函数)
```go
// 1 1 2 3 5 8 13 21 34
package main

import "fmt"

func fab(n int) {
	var a []uint64
	a = make([]uint64, n)

	a[0] = 1
	a[1] = 1
	for i := 2; i < n; i++ {
		a[i] = a[i-1] + a[i-2]
	}
	for _, v := range a {
		fmt.Println(v)
	}
}
func main() {
	fab(10)
}
```
## 数组的初始化
```go
var age0 [5]int = [5]int{1, 2, 3}
var age1 = [5]int{1, 2, 3, 4, 5}
var age2 = [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9}
var age3 = [...]int{2:100,5:200}
var str = [5]string{3: "hello world", 4: "tom"}
fmt.Println(age0, age1, age2, age3, str)

// [1 2 3 0 0] [1 2 3 4 5] [1 2 3 4 5 6 7 8 9] [0 0 100 0 0 200] [   hello world tom]
```

## 多维数组
```go
var age [5][3]int
var f [2][3]int =[...][3]int{{1,2,3,4},{6,7,5,3}} //俩行，每一行是3个元素
```
## 多维数组遍历
```go
var f [2][5]int = [...][5]int{{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}} //2行5列
for row, v := range f { //遍历行，v其实也就是一个数组
	for col, v1 := range v { //遍历列
		fmt.Printf("{%d,%d}=%d", row, col, v1) //坐标的值
	}
	fmt.Println()
}
// {0,0}=1{0,1}=2{0,2}=3{0,3}=4{0,4}=5
// {1,0}=6{1,1}=7{1,2}=8{1,3}=9{1,4}=10
```
# 切片相关特性

1. 切片：切片是数组的一个引用，因此切片是引用类型
2. 切片的长度是可以改变，因此，切片是一个可变的数组
3. 切片遍历方式和数组一样，可以用len()求长度
4. cap可以求出slice最大的容量，`0<=len(slice) <= cap(array)`,其中array是slice引用的数组
5. 切片的定义：
`var 变量名 []类型，比如 var str []string      var arr []int`

## 切片的初始化
1. 切片初始化：`var slice []int = arr[start:end]` 包含start到end之间的元素，但不包含end
2. `var slice []int = arr[0:end]` 可以简写为`var slice []int=arr[:end]`
3. `var slice []int = arr[start:len(arr)]` 可以简写为`var slice []int = arr[start:]`
4. `var slice []int = arr[0,len(arr)]`可以简写为`var slice []int = arr[:]`
5. 如果要切片最后一个元素去掉，可以这么写：`slice=slice[:len(slice)-1]`